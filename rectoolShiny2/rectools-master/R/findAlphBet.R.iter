
# multiplicative random effects model:  the rating Y, 0 or 1, is
# generated by
# 
# EY_ij = alpha_i beta_j
#
# using Method of Moments

# arguments:

#   ratingsIn: input data, with first cols (userID,itemID,rating,
#              covariates); data frame, unless cls is non-null, in which
#              case this argument is the quoted name of the distributed 
#              data frame
#   q:  initial value of the beta_j
#   niters:  number of iterations

# value:

#   S3 class of type "alphbet", with components:

#      alphavec: the alpha_i
#      betavec: the beta_j

findAlphBet <- function(ratingsIn,betavec=rep(0.8,nrow(ratingsIn)),niters=10) { 
   users = ratingsIn[,1] 
   items = ratingsIn[,2] 
   ratings = ratingsIn[,3] 
   linenums <- 1:nrow(ratingsIn)
   userseqnums <- split(linenums,users)
   itemseqnums <- split(linenums,items)
   usernsinv <- 1 / sapply(userseqnums,length)
   itemnsinv <- 1 / sapply(itemseqnums,length)
   useritemnums <- lapply(userseqnums,
      function(oneuserseqs) items[oneuserseqs])
   itemusernums <- lapply(itemseqnums,
      function(oneitemseqs) users[oneitemseqs])
   yidots <- sapply(userseqnums,
      function(oneuserseqs) mean(ratings[oneuserseqs]))
   ydotjs <- sapply(itemseqnums,
      function(oneitemseqs) mean(ratings[oneitemseqs]))
   for (i in 1:niters) {
      print(i)
      # alpha phase
      betprods <- sapply(useritemnums,
         function(oneuserseqs) prod(betavec[oneuserseqs]))
      alphavec <- (yidots / betprods) ^ usernsinv
      alphavec <- pmin(alphavec,1)
      print(alphavec[1:5])
      # beta phase
      alpprods <- sapply(itemusernums,
         function(oneitemseqs) prod(alphavec[oneitemseqs]))
      betavec <- (ydotjs / alpprods) ^ itemnsinv
      betavec <- pmin(betavec,50)
      cat('   ',betavec[1:5],'\n')
   }
   list(alpha=alphavec,beta=betavec,yidots=yidots,ydotjs=ydotjs)
} 

# predict() method for the 'ydots' class
#
# testSet in same form as ratingsIn in findYdots(), except that there 
# is no ratings column; regObj is as in the output of findYdots()
#
# returns vector of predicted values for testSet
predict.ydotsMM = function(ydotsObj,testSet) {
   testSet$pred = ydotsObj$usrMeans[as.character(testSet[,1])] + 
      ydotsObj$itmMeans[as.character(testSet[,2])] - ydotsObj$grandMean
   if (!is.null(ydotsObj$regObj))
      testSet$pred = testSet$pred + predict(ydotsObj$regObj,testSet[,-(1:2)])
   testSet$pred
}

