
# multiplicative random effects model:  the rating Y, 0 or 1, is
# generated by
# 
# EY_ij = alpha_i beta_j
#
# using Method of Moments

# arguments:

#   ratingsIn: input data, with first cols (userID,itemID,rating,
#              covariates); data frame, unless cls is non-null, in which
#              case this argument is the quoted name of the distributed 
#              data frame
#   q:  initial value of the beta_j
#   niters:  number of iterations

# value:

#   S3 class of type "alphbet", with components:

#      alph: the alpha_i
#      bet: the beta_j

findYdotsAlphBet <- function(ratingsIn,q=0.8) { 
   users = ratingsIn[,1] 
   items = ratingsIn[,2] 
   ratings = ratingsIn[,3] 
   nms <- names(ratingsIn)
   # for each user i, find the items she rated, storing their indices in
   # userrated[[i]]
   userrated  <- split(items,users)
   # for each item j, find the users who rated this item, storing their
   # indices in userrated[[i]]
   itemratedby <- split(users,items)
   yidots <- sapply(userrated,mean)
   ydotjs <- sapply(itemrated,mean)
   bet <- rep(0.
   for (i in 1:niters) {
   }
} 

# predict() method for the 'ydots' class
#
# testSet in same form as ratingsIn in findYdots(), except that there 
# is no ratings column; regObj is as in the output of findYdots()
#
# returns vector of predicted values for testSet
predict.ydotsMM = function(ydotsObj,testSet) {
   testSet$pred = ydotsObj$usrMeans[as.character(testSet[,1])] + 
      ydotsObj$itmMeans[as.character(testSet[,2])] - ydotsObj$grandMean
   if (!is.null(ydotsObj$regObj))
      testSet$pred = testSet$pred + predict(ydotsObj$regObj,testSet[,-(1:2)])
   testSet$pred
}

