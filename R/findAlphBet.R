
# multiplicative random effects model:  the rating Y, 0 or 1, is
# generated by
# 
# EY_ij = alpha_i beta_j
#
# using Method of Moments

# in order to be identifiable, this model needs either alpha or beta to
# be a fixed constant; otherwise, we could, say, halve the alphas and
# double the betas, with the same products

# arguments:

#   ratingsIn: input data, with first cols (userID,itemID,rating,
#              covariates); data frame

# value:

#   S3 class of type "MMmultiplic", with components:

#      alphavec: the alpha_i
#      betavec: the beta_j
#

findAlphBet <- function(ratingsIn) {
   users = ratingsIn[,1] 
   items = ratingsIn[,2] 
   ratings = ratingsIn[,3] 
   linenums <- 1:nrow(ratingsIn)
   userseqnums <- split(linenums,users)
   itemseqnums <- split(linenums,items)
   yidots <- sapply(userseqnums,
      function(oneuserseqs) mean(ratings[oneuserseqs]))
   ydotjs <- sapply(itemseqnums,
      function(oneitemseqs) mean(ratings[oneitemseqs]))
   ydotdot <- mean(ratings)
   # for identifiability, need the beta_j to be a fixed value
   betavec <- rep(1.0,length(itemseqnums))
   names(betavec) <- 1:length(itemseqnums)
   alphavec <- yidots 
   res <- list(alphavec=alphavec,betavec=betavec,yidots=yidots,ydotjs=ydotjs)
   class(res) <- 'MMmultiplic'
   res
} 

# predict() method for the 'MMmultiplic' class
#
# testSet in same form as ratingsIn above, except that there 
# is no ratings column 

# MMmultiplic is the output of findAlphBet()
#
# returns vector of predicted values for testSet
predict.MMmultiplic = function(multiplicObj,testSet) {
   pred = 
      multiplicObj$alphavec[as.character(testSet[,1])] * 
      multiplicObj$betavec[as.character(testSet[,2])] 
   pred
}


# predict() method for the 'ydots' class
#
# testSet in same form as ratingsIn in findYdots(), except that there 
# is no ratings column; regObj is as in the output of findYdots()
#
# returns vector of predicted values for testSet
predict.ydotsMM = function(ydotsObj,testSet) {
   testSet$pred = ydotsObj$usrMeans[as.character(testSet[,1])] + 
      ydotsObj$itmMeans[as.character(testSet[,2])] - ydotsObj$grandMean
   if (!is.null(ydotsObj$regObj))
      testSet$pred = testSet$pred + predict(ydotsObj$regObj,testSet[,-(1:2)])
   testSet$pred
}

