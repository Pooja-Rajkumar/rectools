
# multiplicative random effects model:  the rating Y, 0 or 1, is
# generated by
# 
# EY_ij = alpha_i beta_j
#
# using Method of Moments

# arguments:

#   ratingsIn: input data, with first cols (userID,itemID,rating,
#              covariates); data frame, unless cls is non-null, in which
#              case this argument is the quoted name of the distributed 
#              data frame
#   q:  initial value of the beta_j
#   niters:  number of iterations

# value:

#   S3 class of type "alphbet", with components:

#      alpha: the alpha_i
#      beta: the beta_j

findAlphBet <- function(ratingsIn,q=0.8,niters=10) { 
   users = ratingsIn[,1] 
   items = ratingsIn[,2] 
   ratings = ratingsIn[,3] 
   linenums <- 1:nrow(ratingsIn)
   userseqnums <- split(linenums,users)
   itemseqnums <- split(linenums,items)

   useritemnums <- items[userseqnums]
   itemusernums <- users[itemseqnums]
   ratingsbyuser <- ratings[userseqnums]
   ratingsbyitem <- ratings[itemseqnums]
   yidots <- sapply(ratingsbyuser,mean)
   ydotjs <- sapply(ratingsbyitem,mean)
   for (i in 1:niters) {
      # alpha phase
      betprods <- prod(beta[useritemnums])
      alpha <- yidots / betprods
      # beta phase
      alpprods <- prod(alpha[itemusernums])
      beta <- ydotjs / alpprods
   }
   list(alpha=alpha,beta=beta,yidots=yidots,ydotjs=ydotjs)
} 

# predict() method for the 'ydots' class
#
# testSet in same form as ratingsIn in findYdots(), except that there 
# is no ratings column; regObj is as in the output of findYdots()
#
# returns vector of predicted values for testSet
predict.ydotsMM = function(ydotsObj,testSet) {
   testSet$pred = ydotsObj$usrMeans[as.character(testSet[,1])] + 
      ydotsObj$itmMeans[as.character(testSet[,2])] - ydotsObj$grandMean
   if (!is.null(ydotsObj$regObj))
      testSet$pred = testSet$pred + predict(ydotsObj$regObj,testSet[,-(1:2)])
   testSet$pred
}

